Longer term:
** stokes flow example
** higher order bases
** simple adaptive meshing
** faster near-field matrix construction
-- try the nearly singular tri rule = 
    http://www98.griffith.edu.au/dspace/bitstream/handle/10072
    /54329/86520_1.pdf?sequence=1

TASKS:
-- Vector direct_interact

-- Some profiling on the functions inside an iterative matrix solve

-- Link BEM to FMM

-- Consider a different way of handling constraints. precompute reduced matrix?

-- A way of computing the condition number of a BEM matrix.

-- Be consistent about which files contain outwards facing API and which files contain implementation details.

-- Add some of the tests from codim1_dev for add_vec_with_constraints to test_constraints

-- Tests for inhomogeneous constraints

-- Move some of the stuff from numerics into basis.h

-- Make the constrained dof first, not last! simpler

-- Currently, add_vec_with_constraints requires recursing down the constraint matrix. I suspect there is an alternate formulation that does not require recursion. Maybe recursive constraints could be dealt with upfront

-- Currently, add_vec_with_constraints is built around side effects on an input vector. This should be modified to be side effect free.

-- Find a simple solution to the O(N^2) problem in mesh_continuity and apply_discontinuities.

-- DOF handling should be more systematic with a face_id and vertex_id for each dof_id. This needs a bidirectional mapping, especially for some of the constraints code.

-- Pull some of vec.h out into a separate module "geometry.h"

-- Consider using CGAL or other big fancy libraries for computational geometry

-- Tests for the 2D and 3D adaptive_nearfield quadrature.

-- A better approximation to the distance to a face might include the centroid (see appx_face_dist2)

-- Once FMM-BEM integration is completed, a sparse matrix storage format should be used for the nearfield entries.

-- Consider getting rid of refine_mod and friends in Mesh.

-- Should I handle hanging nodes in finding mesh continuity constraints

-- Handle the general case when fault-surface intersection does not occur at a vertex.

-- Consider getting rid of autocheck as a dependency.

-- Slight encapsulation of the std::vector storage with useful things like negation, element-wise multiplication, etc. This might be useful to combine with a MeshField style field-over-mesh sitution.

FMM STUFF:

-- Make Box an immutable data type.

-- Make OctreeCell an immutable data type.

-- Within FMMInfo::P2M_helper: Extract P2M_cell_cell.

-- Within FMMInfo::L2P_helper: Extract this function as L2P_cell_cell.

-- The FMM code requires significant refactoring:(immutable data types, use a recurse and coalesce strategy for accumulating the jobs, get rid of the float_ variables, use a recurse and coalesce strategy for accumulating the multipoles and locals, make sure these modifications don't damage the efficiency, more uniform naming for global, cell-wise, node-wise operations in the FMM application)

-- To parallelize octree construction, don't build the tree top-down. Build it from the bottom-up. Every element knows its position in the tree already, I just need to compute the morton code on each level to determine that.  The problem becomes adaptivity. To achieve adaptivity, I could temporarily build a hash table mapping cells to a list of elements and then statically convert that into a top-down tree. But, because the lower nodes are already constructed, constructing the upper nodes is not dependent on them -- in other words, this construction is completely parallelizable.

-- Extract a get_box or get_single_pt_box function or both from the Octree::build_child function

-- The min_code and max_code may not be necessary in OctreeCell except for construction.

-- Make Octree an immutable data type.
