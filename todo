TESTS:
-- Tests for the 2D and 3D adaptive_nearfield quadrature.
-- Can some decoupling be done so that individual pieces of direct_interact can be tested indepedently in unit tests rather than integration tests.
-- Decoupling to allow testing individual pieces of the FMM algorithm.

DESIGN DECISIONS:
-- Should I use CGAL or other comp-geom library (WRITE A NOTE ON THE DECISION)

-- Think about decoupling the library into multiple .so files, so that individual pieces can be tested independently. (WRITE A NOTE ON THE DECISION)

-- Alternately, think about the viability of a header-only library. (WRITE A NOTE ON THE DECISION)

----http://stackoverflow.com/questions/12671383/benefits-of-header-only-libraries 
----http://stackoverflow.com/questions/12290639/quantifiable-metrics-benchmarks-on-the-usage-of-header-only-c-libraries/13593041#13593041
----http://stackoverflow.com/questions/6200752/c-header-only-template-library/6200793#6200793
----http://stackoverflow.com/questions/1783849/what-are-the-advantages-and-disadvantages-of-implementing-classes-in-header-file/1783905#1783905

-- Revamp the build system so that individual tests can be run without recompiling the whole system. (WRITE A NOTE ON THE BUILD SYSTEM DESIGN)

-- Consider a different way of handling constraints. precompute reduced matrix?

NEW FUNCTIONALITY:
-- Link BEM to FMM
-- Hanging nodes
-- A way of computing the condition number of a BEM matrix.
-- Find a simple solution to the O(N^2) problem in mesh_continuity and apply_discontinuities.
-- DOF handling should be more systematic with a face_id and vertex_id for each dof_id. This needs a bidirectional mapping, especially for some of the constraints code.
-- A better approximation to the distance to a face might include the centroid (see appx_face_dist2)
-- Once FMM-BEM integration is completed, a sparse matrix storage format should be used for the nearfield entries.
-- Handle the general case when fault-surface intersection does not occur at a vertex.
-- Slight encapsulation of the std::vector storage with useful things like negation, element-wise multiplication, etc. This might be useful to combine with a MeshField style field-over-mesh sitution.
-- To parallelize octree construction, don't build the tree top-down. Build it from the bottom-up. Every element knows its position in the tree already, I just need to compute the morton code on each level to determine that.  The problem becomes adaptivity. To achieve adaptivity, I could temporarily build a hash table mapping cells to a list of elements and then statically convert that into a top-down tree. But, because the lower nodes are already constructed, constructing the upper nodes is not dependent on them -- in other words, this construction is completely parallelizable.

MODIFIED FUNCTIONALITY:
-- Currently, add_vec_with_constraints requires recursing down the constraint matrix. I suspect there is an alternate formulation that does not require recursion. Maybe recursive constraints could be dealt with upfront
-- Currently, add_vec_with_constraints is built around side effects on an input vector. This should be modified to be side effect free.
-- Consider getting rid of refine_mod and friends in Mesh.
-- Currently, do constraints overwrite each other? Say 1 == 3 and 2 == 3. Then only one constraint survives, right? This is WRONG.

STRUCTURAL:
-- KernelData object 
-- Be consistent about which files contain outwards facing API and which files contain implementation details.
-- Pull some of vec.h out into a separate module "geometry.h"
-- Consider getting rid of autocheck as a dependency.
-- Make Box an immutable data type.
-- Make OctreeCell an immutable data type.
-- Within FMMInfo::P2M_helper: Extract P2M_cell_cell.
-- Within FMMInfo::L2P_helper: Extract this function as L2P_cell_cell.
-- The FMM code requires significant refactoring:(immutable data types, use a recurse and coalesce strategy for accumulating the jobs, get rid of the float_ variables, use a recurse and coalesce strategy for accumulating the multipoles and locals, make sure these modifications don't damage the efficiency, more uniform naming for global, cell-wise, node-wise operations in the FMM application)
-- Extract a get_box or get_single_pt_box function or both from the Octree::build_child function. In general, make that function more testable.
-- The min_code and max_code may not be necessary in OctreeCell except for construction.
-- Make Octree an immutable data type. 

OPTIMIZATION:
-- Some profiling on the functions inside an iterative matrix solve. I think a couple hours would get a factor of 5-10 here. Lots of inefficiencies. Low priority though.

LONG TERM:
** stokes flow example
** higher order bases
** simple adaptive meshing
** faster near-field matrix construction
-- try the nearly singular tri rule = 
    http://www98.griffith.edu.au/dspace/bitstream/handle/10072
    /54329/86520_1.pdf?sequence=1
** python (mako, titen, etc) templating based solution for code generation.
-- http://szelei.me/code-generator/
-- http://eli.thegreenplace.net/2011/07/03/parsing-c-in-python-with-clang/
