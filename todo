CURRENT: FMM 
** Imagine some kind of general purpose "nearfield" structure that can allow a simple O(N) solution to the near neighbors problems in mesh_continuity, apply_discontinuities as well as the FMM tree structure.
** FMM (as opposed to the current treecode)!
** Centralization the kernel application function
** Precompute the DAG of FMM operations -- this will allow simple, but powerful  and scalable parallelism -- look at starpu
** see how the accuracy changes as a function of
    1) radius of equivalent surface
    2) radius of check surface
    3) order of expansion
    4) multipole acceptance criteria
** Get the tensor kernels working with FMM
** 3D fmm tests
** regularized equiv to check operator (A^T A + \alpha I)
    (how does the value of alpha change the accuracy?)
** think about whether the direct treecode inversion algorithm is worthwhile



MISC:
** hanging nodes!
** crack-tip elements
** characterize the galerkin BEM for hypersingular kernels
** characterize the sinh-sigmoidal method
** get rid of non-block operators and rename "Block___" to "___"
** Storing the kernel by reference in the integration methods is bad. fix.
** link the python via numpy
** include the boost python libraries with the code.
** Clear out all "inline"
** consider getting rid of vectorx
---------------------------------------

MILESTONE: HANGING NODES AND COMPLEX GEOMETRIES
S: Pull some of vec.h out into a separate module "geometry.h"
NF: Hanging nodes?
NF: Handle the general case when fault-surface intersection does not occur at a vertex.
---- Linked to hanging nodes in that lots of geometry code needs to be used/written.
---- (DD) Should I use CGAL or other comp-geom library (write a note on the decision)
