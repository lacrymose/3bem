TESTS:
-- Tests for the 2D and 3D adaptive_nearfield quadrature.
-- Can some decoupling be done so that individual pieces of direct_interact can be tested indepedently in unit tests rather than integration tests.
-- Reduce the time cost of test_fmm. Decoupling? Move the slow parts to an integration test.

DESIGN DECISIONS:
-- Should I handle hanging nodes in finding mesh continuity constraints (WRITE A NOTE ON THE DECISION)
-- Should I use CGAL or other comp-geom library (WRITE A NOTE ON THE DECISION)
-- Think about decoupling the library into multiple .so files, so that individual pieces can be tested independently.-
-- Alternately, think about the viability of a header-only library

NEW FUNCTIONALITY:
-- Vector direct_interact
-- Constraints applied to vector datatypes.
-- Link BEM to FMM
-- Consider a different way of handling constraints. precompute reduced matrix?
-- A way of computing the condition number of a BEM matrix.
-- Find a simple solution to the O(N^2) problem in mesh_continuity and apply_discontinuities.
-- DOF handling should be more systematic with a face_id and vertex_id for each dof_id. This needs a bidirectional mapping, especially for some of the constraints code.
-- A better approximation to the distance to a face might include the centroid (see appx_face_dist2)
-- Once FMM-BEM integration is completed, a sparse matrix storage format should be used for the nearfield entries.
-- Handle the general case when fault-surface intersection does not occur at a vertex.
-- Slight encapsulation of the std::vector storage with useful things like negation, element-wise multiplication, etc. This might be useful to combine with a MeshField style field-over-mesh sitution.
-- To parallelize octree construction, don't build the tree top-down. Build it from the bottom-up. Every element knows its position in the tree already, I just need to compute the morton code on each level to determine that.  The problem becomes adaptivity. To achieve adaptivity, I could temporarily build a hash table mapping cells to a list of elements and then statically convert that into a top-down tree. But, because the lower nodes are already constructed, constructing the upper nodes is not dependent on them -- in other words, this construction is completely parallelizable.

MODIFIED FUNCTIONALITY:
-- Make the constrained dof first, not last! simpler
-- Currently, add_vec_with_constraints requires recursing down the constraint matrix. I suspect there is an alternate formulation that does not require recursion. Maybe recursive constraints could be dealt with upfront
-- Currently, add_vec_with_constraints is built around side effects on an input vector. This should be modified to be side effect free.
-- Consider getting rid of refine_mod and friends in Mesh.

STRUCTURAL:
-- KernelData object 
-- Be consistent about which files contain outwards facing API and which files contain implementation details.
-- Pull some of vec.h out into a separate module "geometry.h"
-- Consider getting rid of autocheck as a dependency.
-- Make Box an immutable data type.
-- Make OctreeCell an immutable data type.
-- Within FMMInfo::P2M_helper: Extract P2M_cell_cell.
-- Within FMMInfo::L2P_helper: Extract this function as L2P_cell_cell.
-- The FMM code requires significant refactoring:(immutable data types, use a recurse and coalesce strategy for accumulating the jobs, get rid of the float_ variables, use a recurse and coalesce strategy for accumulating the multipoles and locals, make sure these modifications don't damage the efficiency, more uniform naming for global, cell-wise, node-wise operations in the FMM application)
-- Extract a get_box or get_single_pt_box function or both from the Octree::build_child function
-- The min_code and max_code may not be necessary in OctreeCell except for construction.
-- Make Octree an immutable data type.

OPTIMIZATION:
-- Some profiling on the functions inside an iterative matrix solve

LONG TERM:
** stokes flow example
** higher order bases
** simple adaptive meshing
** faster near-field matrix construction
-- try the nearly singular tri rule = 
    http://www98.griffith.edu.au/dspace/bitstream/handle/10072
    /54329/86520_1.pdf?sequence=1
** python (mako, titen, etc) templating based solution for code generation.
-- http://szelei.me/code-generator/
-- http://eli.thegreenplace.net/2011/07/03/parsing-c-in-python-with-clang/
