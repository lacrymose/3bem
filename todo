TOP PRIORITY -- BLOCKING PROGRESS ON ELASTIC SOLVER:
Goal1: Be able to constrain different components of a vector field differently.
MF: Come up with a good way to separate out components of a vector/tensor.
NF: Different Constraints for each row of a vector
NF: Decide whether to allow separating out individual rows or components of the tensor kernels. Adds complexity and a little bit of value, but the same thing can be achieved using the full tensor kernels and constraints. Is this true? If a different integral equation (traction vs. displacement) were used for the various rows, then constraints would not suffice. Interesting. Is there a way to easily build a tensor kernel out of a variety of components?
NF: DOF handling should be more systematic with a mesh_identifier, a face_id, a vertex_id, and a component_id for each dof_id. This needs a bidirectional mapping, especially for some of the constraints code. I should also account for the tensor/vector nature of certain fields. 


---------------------------------------

HANGING NODES AND COMPLEX GEOMETRIES:
S: more flexible build system -- debug vs release vs profile vs test_coverage?
DD: Define much much clearer interfaces with the outside world.
-- Maybe restrict the main .h files to outward facing interfaces. I could use _impl.h files for inward facing header files. I could try this with constraints.h
S: Consider getting rid of autocheck as a dependency.
-- better random number generation in util.h, maybe separate out to random.h?
S: Pull some of vec.h out into a separate module "geometry.h"
NF: Hanging nodes?
NF: Handle the general case when fault-surface intersection does not occur at a vertex.
---- Linked to hanging nodes in that lots of geometry code needs to be used/written.
---- (DD) Should I use CGAL or other comp-geom library (write a note on the decision)

---------------------------------------

FMM-BEM INTEGRATION:
NF: Interface for Operators -- extend with sparse matrix operators and FMMOperator
-- move mat_mult to be a member function for an operator?
NF: Imagine some kind of general purpose "nearfield" structure that can allow a simple O(N) solution to the near neighbors problems in mesh_continuity, apply_discontinuities as well as the FMM tree structure.
NF: Once FMM-BEM integration is completed, a sparse matrix storage format should be used for the nearfield entries.
NF: A method that creates a non-matrix based operator that consists of strengths of point sources. First, evaluate this with a direct multiplication interaction.
NF: Used the FMMOperator to perform an FMM evaluation within an iteration. 
S: Make Box an immutable data type.
S: Make OctreeCell an immutable data type.
S: Within FMMInfo::P2M_helper: Extract P2M_cell_cell.
S: Within FMMInfo::L2P_helper: Extract L2P_cell_cell.
S: The FMM code requires significant refactoring:(immutable data types, use a recurse and coalesce strategy for accumulating the jobs, get rid of the float_ variables, use a recurse and coalesce strategy for accumulating the multipoles and locals, make sure these modifications don't damage the efficiency, more uniform naming for global, cell-wise, node-wise operations in the FMM application)
S: Decoupling to allow testing individual pieces of the FMM algorithm.
S: Extract a get_box or get_single_pt_box function or both from the Octree::build_child function. In general, make that function more testable.
S: The min_code and max_code may not be necessary in OctreeCell except for construction.
S: Make Octree an immutable data type. 

--------------------------------------- Unaffiliated tasks
TESTS(T):
DESIGN DECISIONS(DD):
NEW FUNCTIONALITY(NF):
MODIFIED FUNCTIONALITY(MF):
STRUCTURAL(S):
OPTIMIZATION(O):



Possibly sidelined (forever?):
Goal2: More elegant handling of discretized Functions (in the mathematical sense).
MF: Replace std::vector with the Function class in Problem
NF: Slight encapsulation of the std::vector storage with useful things like negation, element-wise multiplication, etc. This might be useful to combine with Function.
