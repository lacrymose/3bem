CURRENT: FMM 
** FMM (as opposed to the current treecode)!
** move obs, src loop into the kernel functions
** Precompute the DAG of FMM operations -- this will allow simple, but powerful  and scalable parallelism -- look at starpu
** think about whether the direct treecode inversion algorithm is worthwhile

** SVD equiv to check
-- Eigen SVD is obscenely slow. See what else is out there!

** debug the occasional failure of the fmm algorithm?!

** move unittest-cpp and autocheck inside the repository

MISC:
** see how FMM accuracy changes as a function of
    1) radius of equivalent surface
    2) radius of check surface
    3) order of expansion
    4) multipole acceptance criteria

** hanging nodes!
** nearest_neighbors for point->triangle or triangle->triangle intersection
** Handle the general case when fault-surface intersection does not occur at a vertex.
-- Linked to hanging nodes in that lots of geometry code needs to be used/written.
-- (DD) Should I use CGAL or other comp-geom library (write a note on the decision)

** crack-tip elements
** characterize the galerkin BEM for hypersingular kernels
** characterize the sinh-sigmoidal method
** get rid of non-block operators and rename "Block___" to "___"
** Storing the kernel by reference in the integration methods is bad. fix.
** Clear out all "inline"
** consider getting rid of vectorx
** use iterators for traversing point sets?

BETTER BUILD SYSTEM:
** test the build system on mac, windows, a fresh ubuntu, odyssey/meade02
** kill the boost dependency, replace with cython wrappers
---------------------------------------

MILESTONE: HANGING NODES AND COMPLEX GEOMETRIES
S: Pull some of vec.h out into a separate module "geometry.h"
